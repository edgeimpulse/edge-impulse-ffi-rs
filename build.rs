use std::env;
use std::fs;
use std::path::PathBuf;
use std::process::Command;

mod build_helpers;

fn clean_model_folder() {
    let model_dir = "model";

    // Check if model directory exists
    if !fs::metadata(model_dir).is_ok() {
        println!("Model directory does not exist, nothing to clean");
        return;
    }

    // Read all entries in the model directory
    let entries = match fs::read_dir(model_dir) {
        Ok(entries) => entries,
        Err(e) => {
            eprintln!("Failed to read model directory: {}", e);
            return;
        }
    };

    for entry in entries {
        let entry = match entry {
            Ok(entry) => entry,
            Err(e) => {
                eprintln!("Failed to read directory entry: {}", e);
                continue;
            }
        };

        let path = entry.path();
        let file_name = path.file_name().unwrap_or_default();

        // Skip README.md and .gitignore
        if file_name == "README.md" || file_name == ".gitignore" {
            continue;
        }

        // Remove the entry (file or directory)
        if path.is_dir() {
            if let Err(e) = fs::remove_dir_all(&path) {
                eprintln!("Failed to remove directory {:?}: {}", path, e);
            } else {
                println!("Removed directory: {:?}", path);
            }
        } else {
            if let Err(e) = fs::remove_file(&path) {
                eprintln!("Failed to remove file {:?}: {}", path, e);
            } else {
                println!("Removed file: {:?}", path);
            }
        }
    }

    println!("Model folder cleaned successfully. Only README.md and .gitignore remain.");
}

fn extract_and_write_model_metadata() {
    use std::collections::HashMap;
    use std::fs;
    let header_path = "model/model-parameters/model_metadata.h";
    let out_path = "src/model_metadata.rs";
    let header = fs::read_to_string(header_path).expect("Failed to read model_metadata.h");

    let mut out = String::from("// This file is @generated by build.rs. Do not edit manually.\n");
    out.push_str("// Model metadata constants extracted from model_metadata.h\n\n");

    let mut seen = HashMap::new();
    let mut raw_defs = Vec::new();

    // First pass: collect all constants and their raw values
    for line in header.lines() {
        if let Some(rest) = line.strip_prefix("#define ") {
            let mut parts = rest.splitn(3, ' ');
            let name = parts.next();
            let val = parts.next();
            let val_rest = parts.next();
            if let (Some(name), Some(val)) = (name, val) {
                let value = if let Some(rest) = val_rest {
                    // Value is everything after the name
                    format!("{} {}", val, rest).trim().to_string()
                } else {
                    val.trim().to_string()
                };
                if !(name.starts_with("EI_CLASSIFIER_") || name.starts_with("EI_ANOMALY_TYPE_")) {
                    continue;
                }
                if seen.contains_key(name) {
                    continue;
                }
                raw_defs.push((name.to_string(), value.clone()));
                seen.insert(name.to_string(), value);
            }
        }
    }

    // Helper to resolve a constant recursively
    fn resolve<'a>(name: &str, emitted: &'a HashMap<String, String>) -> Option<String> {
        let mut current = name;
        let mut count = 0;
        while let Some(val) = emitted.get(current) {
            if val.starts_with('"') && val.ends_with('"') {
                return Some(val.clone());
            }
            if let Ok(_) = val.parse::<i32>() {
                return Some(val.clone());
            }
            if let Ok(_) = val.parse::<f32>() {
                return Some(val.clone());
            }
            current = val;
            count += 1;
            if count > 10 {
                break;
            } // prevent infinite loop
        }
        None
    }

    // Second pass: resolve references and emit Rust constants
    let mut emitted = HashMap::new();
    for (name, val) in &raw_defs {
        // Omit type alias constants
        if val == "uint8_t" || val == "bool" || val == "size_t" {
            continue;
        }
        // Special-case EI_CLASSIFIER_SENSOR: always emit as i32
        if name == "EI_CLASSIFIER_SENSOR" {
            // Try to resolve recursively
            let resolved = if let Some(resolved) = resolve(val, &emitted) {
                resolved
            } else {
                val.clone()
            };
            if let Ok(num) = resolved.parse::<i32>() {
                out.push_str(&format!(
                    "pub const {}: i32 = {};
",
                    name, num
                ));
                emitted.insert(name.clone(), num.to_string());
            } else {
                out.push_str(&format!(
                    "// Could not resolve EI_CLASSIFIER_SENSOR as i32: {}\n",
                    resolved
                ));
            }
            continue;
        }
        // String constants
        if val.starts_with('"') && val.ends_with('"') {
            out.push_str(&format!(
                "pub const {}: &str = {};
",
                name, val
            ));
            emitted.insert(name.clone(), val.clone());
            continue;
        }
        // Numeric constants
        if let Ok(num) = val.parse::<i32>() {
            if num < 0 {
                out.push_str(&format!(
                    "pub const {}: i32 = {};
",
                    name, num
                ));
            } else {
                out.push_str(&format!(
                    "pub const {}: usize = {};
",
                    name, num
                ));
            }
            emitted.insert(name.clone(), val.clone());
            continue;
        }
        if let Ok(num) = val.parse::<f32>() {
            out.push_str(&format!(
                "pub const {}: f32 = {};
",
                name, num
            ));
            emitted.insert(name.clone(), val.clone());
            continue;
        }
        // Reference to another constant
        if let Some(resolved) = emitted.get(val) {
            // Use the resolved value and type
            if resolved.starts_with('"') && resolved.ends_with('"') {
                out.push_str(&format!(
                    "pub const {}: &str = {};
",
                    name, resolved
                ));
            } else if let Ok(num) = resolved.parse::<i32>() {
                if num < 0 {
                    out.push_str(&format!(
                        "pub const {}: i32 = {};
",
                        name, num
                    ));
                } else {
                    out.push_str(&format!(
                        "pub const {}: usize = {};
",
                        name, num
                    ));
                }
            } else if let Ok(num) = resolved.parse::<f32>() {
                out.push_str(&format!(
                    "pub const {}: f32 = {};
",
                    name, num
                ));
            } else {
                out.push_str(&format!(
                    "pub const {}: usize = {};
",
                    name, resolved
                ));
            }
            emitted.insert(name.clone(), resolved.clone());
            continue;
        }
        // Special case: EI_CLASSIFIER_SLICE_SIZE
        if name == "EI_CLASSIFIER_SLICE_SIZE" {
            // Try to resolve from other constants
            let raw_sample_count = emitted
                .get("EI_CLASSIFIER_RAW_SAMPLE_COUNT")
                .and_then(|v| v.parse::<usize>().ok())
                .unwrap_or(0);
            let slices_per_window = emitted
                .get("EI_CLASSIFIER_SLICES_PER_MODEL_WINDOW")
                .and_then(|v| v.parse::<usize>().ok())
                .unwrap_or(1);
            let value = raw_sample_count / slices_per_window;
            out.push_str(&format!(
                "pub const EI_CLASSIFIER_SLICE_SIZE: usize = {};
",
                value
            ));
            emitted.insert(name.clone(), value.to_string());
            continue;
        }
        // Special case: EI_CLASSIFIER_RESIZE_MODE
        if name == "EI_CLASSIFIER_RESIZE_MODE" {
            // This should resolve to EI_CLASSIFIER_RESIZE_SQUASH (3)
            out.push_str(
                "pub const EI_CLASSIFIER_RESIZE_MODE: usize = EI_CLASSIFIER_RESIZE_SQUASH;\n",
            );
            emitted.insert(name.clone(), "EI_CLASSIFIER_RESIZE_SQUASH".to_string());
            continue;
        }
        // Fallback: emit as a reference (may cause build error, but better than omitting)
        out.push_str(&format!("// Could not resolve: {} = {}\n", name, val));
    }

    // Add missing constants that are referenced but not defined in the header
    if !emitted.contains_key("EI_CLASSIFIER_RESIZE_SQUASH") {
        out.push_str("pub const EI_CLASSIFIER_RESIZE_SQUASH: usize = 3;\n");
    }
    if !emitted.contains_key("EI_CLASSIFIER_RESIZE_FIT_SHORTEST") {
        out.push_str("pub const EI_CLASSIFIER_RESIZE_FIT_SHORTEST: usize = 1;\n");
    }
    if !emitted.contains_key("EI_CLASSIFIER_RESIZE_FIT_LONGEST") {
        out.push_str("pub const EI_CLASSIFIER_RESIZE_FIT_LONGEST: usize = 2;\n");
    }
    if !emitted.contains_key("EI_CLASSIFIER_LAST_LAYER_YOLOV5") {
        out.push_str("pub const EI_CLASSIFIER_LAST_LAYER_YOLOV5: usize = 0;\n");
    }

    fs::write(out_path, out).expect("Failed to write model_metadata.rs");
}

fn main() {
    // Check if we should clean the model folder
    if env::var("CLEAN_MODEL").is_ok() {
        clean_model_folder();
        return;
    }

    // Use 'model' as the only model folder
    let model_dir = "model";
    build_helpers::copy_ffi_glue(model_dir);

    // Update all model references to use model_dir
    let cpp_dir = PathBuf::from(model_dir);
    let build_dir = cpp_dir.join("build");

    // Generate Rust bindings for the C API wrapper
    let bindings = bindgen::Builder::default()
        .header(&format!("{}/edge_impulse_wrapper.h", model_dir))
        // Use C++ mode and the correct standard
        .clang_arg("-xc++")
        .clang_arg("-std=c++17")
        // Add include paths for the SDK
        .clang_arg(&format!("-I{}", model_dir))
        .clang_arg(&format!("-I{}/edge-impulse-sdk", model_dir))
        // Convert C names to Rust naming conventions
        .rustified_enum(".*")
        .default_enum_style(bindgen::EnumVariation::Rust {
            non_exhaustive: false,
        })
        .prepend_enum_name(false)
        .translate_enum_integer_types(true)
        .derive_copy(true)
        .derive_debug(true)
        .derive_default(true)
        .derive_eq(true)
        .derive_hash(true)
        .derive_partialeq(true)
        .derive_partialord(true)
        .derive_ord(true)
        // Be very selective about what we bind to avoid conflicts
        .allowlist_type("ei_impulse_handle_t")
        .allowlist_type("ei_impulse_result_t")
        .allowlist_type("ei_feature_t")
        .allowlist_type("ei_signal_t")
        .allowlist_type("EI_IMPULSE_ERROR")
        .allowlist_type("ei_impulse_result_classification_t")
        .allowlist_type("ei_impulse_result_bounding_box_t")
        .allowlist_type("ei_impulse_result_timing_t")
        .allowlist_function("ei_ffi_run_classifier_init")
        .allowlist_function("ei_ffi_run_classifier_deinit")
        .allowlist_function("ei_ffi_init_impulse")
        .allowlist_function("ei_ffi_run_classifier")
        .allowlist_function("ei_ffi_run_classifier_continuous")
        .allowlist_function("ei_ffi_run_inference")
        .allowlist_function("ei_ffi_signal_from_buffer")
        // Generate bindings
        .generate()
        .expect("Unable to generate bindings");
    bindings
        .write_to_file("src/bindings.rs")
        .expect("Couldn't write bindings!");

    // Add allow attributes to suppress warnings in generated bindings
    let bindings_content =
        std::fs::read_to_string("src/bindings.rs").expect("Failed to read generated bindings");
    let modified_content = format!(
        "#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals)]\n{}",
        bindings_content
    );
    std::fs::write("src/bindings.rs", modified_content).expect("Failed to write modified bindings");

    // Create build directory if it doesn't exist
    std::fs::create_dir_all(&build_dir).expect("Failed to create build directory");

    // Configure CMake with the required macros for C linkage
    let cmake_status = Command::new("cmake")
        .arg("..")
        .arg("-DCMAKE_BUILD_TYPE=Release")
        .arg("-DEIDSP_SIGNAL_C_FN_POINTER=1")
        .arg("-DEI_C_LINKAGE=1")
        .arg("-DBUILD_SHARED_LIBS=OFF") // Build static library
        .current_dir(&build_dir)
        .status()
        .expect("Failed to run cmake configure");

    if !cmake_status.success() {
        panic!("CMake configuration failed");
    }

    // Build the library
    let make_status = Command::new("make")
        .arg("-j")
        .arg(&env::var("NUM_JOBS").unwrap_or_else(|_| "4".to_string()))
        .current_dir(&build_dir)
        .status()
        .expect("Failed to run make");

    if !make_status.success() {
        panic!("Make build failed");
    }

    // Diagnostic: print contents of build directory
    let entries = std::fs::read_dir(&build_dir).expect("Failed to read build directory");
    println!("Contents of {}:", build_dir.display());
    for entry in entries {
        let entry = entry.expect("Failed to read entry");
        println!("  {}", entry.file_name().to_string_lossy());
    }

    // Tell Cargo where to find the built library
    println!("cargo:rustc-link-search=native={}", build_dir.display());

    // Link against the Edge Impulse SDK library
    // The library name will depend on what CMake generates, typically something like "edge-impulse-sdk"
    println!("cargo:rustc-link-lib=static=edge-impulse-sdk");

    // Link against C++ standard library
    println!("cargo:rustc-link-lib=c++");

    // Re-run if any of the source files change
    println!("cargo:rerun-if-changed={}/CMakeLists.txt", model_dir);
    println!(
        "cargo:rerun-if-changed={}/edge_impulse_wrapper.h",
        model_dir
    );
    println!("cargo:rerun-if-changed={}/edge-impulse-sdk", model_dir);
    println!("cargo:rerun-if-changed={}/model-parameters", model_dir);
    println!("cargo:rerun-if-changed={}/tflite-model", model_dir);

    extract_and_write_model_metadata();
}
